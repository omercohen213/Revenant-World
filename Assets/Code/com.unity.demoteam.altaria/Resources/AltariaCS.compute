#pragma kernel kApplyDeformation
#pragma kernel kCalculateCrossProductPerTriangle
#pragma kernel kRecalculateNormals

#define KERNEL_SIZE 64
//#pragma enable_d3d11_debug_symbols
StructuredBuffer<uint2> _AdjacencyListOffsetCount;
StructuredBuffer<uint> _AdjacentTriangleIndices;
StructuredBuffer<float3> _TriangleCrossProd;
RWStructuredBuffer<float3> _TriangleCrossProdRW;
StructuredBuffer<uint> _IndexBuffer;

StructuredBuffer<float> _DeformPatchBuffer;
StructuredBuffer<uint> _PatchDataToVertexIndexMappingBuffer;
uint _DeformPatchVertexOffset;
uint _DeformPatchVertexCount;
float2 _DeformRemapRange;

float _DeformationWeight;
float _DeformationWeightMaskInfluence;

StructuredBuffer<float3> _NeutralPositionsBuffer;
uint _TriangleCount;
uint _VertexCount;

RWByteAddressBuffer _TargetMeshBufferRW;
uint4 _StrideOffsetPosNormTan;

ByteAddressBuffer _MeshColorStreamBuffer;
uint2  _MeshColorStreamOffsetStride;

//input is assumed to be [-1,1]
float RemapDeformation(float p, float2 range)
{
    p = (p * 0.5f) + 0.5f;
    return lerp(range.x, range.y, p);
}

[numthreads(KERNEL_SIZE,1,1)]
void kApplyDeformation (uint id : SV_DispatchThreadID)
{
    if(id >= _DeformPatchVertexCount) return;

    uint vId = _PatchDataToVertexIndexMappingBuffer[_DeformPatchVertexOffset + id];

    float x = RemapDeformation(_DeformPatchBuffer[id * 3], _DeformRemapRange);
    float y = RemapDeformation(_DeformPatchBuffer[id * 3 + 1], _DeformRemapRange);
    float z = RemapDeformation(_DeformPatchBuffer[id * 3 + 2], _DeformRemapRange);

    float3 delta = float3(x,y,z);
    float3 originalPos = _NeutralPositionsBuffer[vId];

    float maskedDeformationWeight = 1.f;
    if(_DeformationWeightMaskInfluence > 0.f)
    {
        uint color = _MeshColorStreamBuffer.Load(vId * _MeshColorStreamOffsetStride.y + _MeshColorStreamOffsetStride.x);
        float maskWeight = saturate((color >> 24) / 255.f);
        maskedDeformationWeight = lerp(maskedDeformationWeight, maskWeight, _DeformationWeightMaskInfluence);
    }
    float3 pos = originalPos + delta * _DeformationWeight * maskedDeformationWeight;

    _TargetMeshBufferRW.Store3(_StrideOffsetPosNormTan.x * vId + _StrideOffsetPosNormTan.y, asuint(pos));
}


[numthreads(KERNEL_SIZE,1,1)]
void kCalculateCrossProductPerTriangle (uint id : SV_DispatchThreadID)
{
    if(id >= _TriangleCount) return;

    uint i0 = _IndexBuffer[id * 3];
    uint i1 = _IndexBuffer[id * 3 + 1];
    uint i2 = _IndexBuffer[id * 3 + 2];

    float3 p0 = asfloat(_TargetMeshBufferRW.Load3(i0 * _StrideOffsetPosNormTan.x + _StrideOffsetPosNormTan.y ));
    float3 p1 = asfloat(_TargetMeshBufferRW.Load3(i1 * _StrideOffsetPosNormTan.x + _StrideOffsetPosNormTan.y ));
    float3 p2 = asfloat(_TargetMeshBufferRW.Load3(i2 * _StrideOffsetPosNormTan.x + _StrideOffsetPosNormTan.y ));

    float3 v1 = p1 - p0;
    float3 v2 = p2 - p0;

    float3 crossProduct = cross(v1, v2);
    _TriangleCrossProdRW[id] = crossProduct;
}


[numthreads(KERNEL_SIZE,1,1)]
void kRecalculateNormals (uint id : SV_DispatchThreadID)
{
    if(id >= _VertexCount) return;

    uint2 adjacencyOffsetCount = _AdjacencyListOffsetCount[id];
    float3 dotProdSum = 0;

    for(uint i = 0; i < adjacencyOffsetCount.y; ++i)
    {
        uint triangleId = _AdjacentTriangleIndices[adjacencyOffsetCount.x + i];
        dotProdSum += _TriangleCrossProd[triangleId];
    }

    float3 normal = normalize(dotProdSum);
    _TargetMeshBufferRW.Store3(id * _StrideOffsetPosNormTan.x + _StrideOffsetPosNormTan.z, asuint(normal));
    
}
